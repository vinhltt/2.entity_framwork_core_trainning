# Using Entity Framework Core to Manipulate Database

- **Section Overview**
    - In this section, we will learn how to use Entity Framework Core to manipulate data in the database.
    - Main topics include:
        - Understanding Tracking and change persistence in EF Core
        - Performing basic CRUD operations (Create, Read, Update, Delete)
        - New methods in EF Core 7+ for performance optimization
        - Managing entity states
        - Handling bulk operations
    - The goals of this section are to help you:
        - Understand and effectively use the Change Tracker
        - Perform data operations safely and efficiently
        - Apply best practices when working with the database
        - Optimize performance for data operations

- Understanding Tracking and Saving Changes
    
    This is the foundational mechanism of EF Core when working with data.
    
    - **`DbContext`** as Unit of Work: As previously mentioned, `DbContext` is not just a bridge but also acts as a "Unit of Work." It manages a set of entities and tracks their states throughout the lifetime of the `DbContext` instance.
    - **Change Tracker:** Each `DbContext` instance has a `ChangeTracker`. Its responsibilities:
        - **Automatic tracking:** When you query data from the database using `DbContext`, the returned entity objects are automatically tracked by the `DbContext`.
        - **Tracking on operations:** When you `Add` a new entity, `Remove` an entity, or **change the value of a property** of a tracked entity, the `ChangeTracker` records these changes.
    - **Entity States:** The `ChangeTracker` maintains a state for each entity it manages. The main states include:
        - `Detached`: The entity is not being tracked by the `DbContext`. This is the state of a newly created object or one retrieved from a different `DbContext` or has been detached.
        - `Unchanged`: The entity is being tracked and has no changes compared to the original data from the database (or since the last `SaveChanges()`).
        - `Added`: The entity has been added to the `DbContext` (using `Add` or `AddRange`) and does not yet exist in the database. `SaveChanges()` will generate an `INSERT` statement.
        - `Modified`: One or more properties of the tracked entity have changed. `SaveChanges()` will generate an `UPDATE` statement.
        - `Deleted`: The entity is being tracked and has been marked for deletion (using `Remove` or `RemoveRange`). `SaveChanges()` will generate a `DELETE` statement.
        - You can check the state of an entity using `context.Entry(entity).State`.
    - **`SaveChanges()`** / **`SaveChangesAsync()`**: This is the **final method** to persist changes to the database. When you call it:
        1. `DbContext` scans all entities being tracked by the `ChangeTracker`.
        2. It detects entities with states `Added`, `Modified`, or `Deleted`.
        3. Based on the state, it generates the corresponding SQL statements (`INSERT`, `UPDATE`, `DELETE`).
        4. It executes these statements in a **single transaction** (by default). If an error occurs, the entire transaction is rolled back, ensuring data integrity.
        5. After successful execution, the states of the entities are updated (e.g., `Added` -> `Unchanged`, `Modified` -> `Unchanged`, `Deleted` -> `Detached`). Values generated by the database (like auto-incremented primary keys) are also updated back into your entity objects.
        
        ```csharp
        // Any changes before this line (Add, Update, Remove) will be prepared
        int affectedRows = await context.SaveChangesAsync(); // Executes SQL and saves changes
        // affectedRows contains the number of records affected in the database
        ```
        
- Simple Insert Operations
    - **Process:** Create object -> Add to Context -> Save changes.
    - **Steps:**
        1. **Create a new instance:** Create a new object of the entity class you want to add.
            
            ```csharp
            var newProduct = new Product
            {
                Name = "New Amazing Gadget",
                Price = 199.99m,
                CategoryId = 1, // Assume CategoryId = 1 exists
                IsAvailable = true
            };
            ```
            
        2. **Add to DbContext:** Use the `Add()` or `AddAsync()` method of `DbSet<T>` (or `DbContext.Add(entity)`). This attaches the entity to the `DbContext` and marks its state as `Added`.
            
            ```csharp
            context.Products.Add(newProduct);
            // Or: await context.Products.AddAsync(newProduct);
            // Or: context.Add(newProduct);
            ```
            
        3. **Add multiple records:** Use `AddRange()` or `AddRangeAsync()` to add multiple entities at once, more efficient than calling `Add()` repeatedly.
            
            ```csharp
            var productsToAdd = new List<Product>
            {
                new Product { Name = "Product A", Price = 10 },
                new Product { Name = "Product B", Price = 20 }
            };
            context.Products.AddRange(productsToAdd);
            // Or: await context.Products.AddRangeAsync(productsToAdd);
            ```
            
        4. **Save changes:** Call `await context.SaveChangesAsync()`. EF Core will generate and execute `INSERT` statements for entities with state `Added`.
            
            ```csharp
            await context.SaveChangesAsync();
            // After SaveChangesAsync succeeds:
            // 1. The state of newProduct (and products in productsToAdd) becomes Unchanged.
            // 2. If Id is an auto-incremented primary key, newProduct.Id will be updated with the new value from the database.
            Console.WriteLine($"New product added with ID: {newProduct.Id}");
            ```
            
- Simple Update Operations
    - **Standard process:** Query -> Modify -> Save changes.
    - **Steps:**
        1. **Query:** Retrieve the entity you want to update from the database using `DbContext`. This entity will now be tracked by the `ChangeTracker` with state `Unchanged`.
            
            ```csharp
            int productIdToUpdate = 101; // ID of the product to update
            var productToUpdate = await context.Products.FindAsync(productIdToUpdate);
            // Or use FirstOrDefaultAsync, SingleOrDefaultAsync, etc.
            // var productToUpdate = await context.Products.FirstOrDefaultAsync(p => p.Id == productIdToUpdate);
            
            if (productToUpdate == null)
            {
                Console.WriteLine("Product not found!");
                return;
            }
            // At this point, context.Entry(productToUpdate).State is Unchanged
            ```
            
        2. **Modify:** Change the values of the desired properties of the retrieved entity.
            
            ```csharp
            Console.WriteLine($"Old price: {productToUpdate.Price}");
            productToUpdate.Price = productToUpdate.Price * 1.1m; // Increase price by 10%
            productToUpdate.IsAvailable = false; // Mark as unavailable
            // As soon as you change the first property (Price),
            // ChangeTracker will automatically detect and change the state of productToUpdate to Modified.
            // Console.WriteLine($"State after modification: {context.Entry(productToUpdate).State}"); // Output: Modified
            ```
            
        3. **Save changes:** Call `await context.SaveChangesAsync()`. EF Core will:
            - Detect `productToUpdate` has state `Modified`.
            - Generate an `UPDATE` statement including only the columns that changed (in this case, `Price` and `IsAvailable`).
            - Execute the `UPDATE` statement in the database.
            - Update the state of `productToUpdate` to `Unchanged`.
            
            ```csharp
            await context.SaveChangesAsync();
            Console.WriteLine($"Product {productIdToUpdate} updated. New price: {productToUpdate.Price}");
            // Console.WriteLine($"State after save: {context.Entry(productToUpdate).State}"); // Output: Unchanged
            ```
            
- Simple Delete Operations
    - **Process:** Query -> Mark for deletion -> Save changes.
    - **Steps:**
        1. **Query:** Retrieve the entity you want to delete from the database. This entity is tracked with state `Unchanged`.
            
            ```csharp
            int productIdToDelete = 102; // ID of the product to delete
            var productToDelete = await context.Products.FindAsync(productIdToDelete);
            
            if (productToDelete == null)
            {
                Console.WriteLine("Product not found!");
                return;
            }
            // context.Entry(productToDelete).State is Unchanged
            ```
            
        2. **Mark for deletion (Remove):** Use the `Remove()` method of `DbSet<T>` (or `DbContext.Remove(entity)`). This **does not delete the entity immediately** but only changes its state in the `ChangeTracker` to `Deleted`.
            
            ```csharp
            context.Products.Remove(productToDelete);
            // Or: context.Remove(productToDelete);
            // Console.WriteLine($"State after remove: {context.Entry(productToDelete).State}"); // Output: Deleted
            ```
            
        3. **Delete multiple records:** Use `RemoveRange()` to mark multiple entities for deletion at once.
            
            ```csharp
            // var productsToDelete = await context.Products.Where(p => p.Price < 10).ToListAsync();
            // context.Products.RemoveRange(productsToDelete);
            ```
            
        4. **Save changes:** Call `await context.SaveChangesAsync()`. EF Core will:
            - Detect `productToDelete` has state `Deleted`.
            - Generate and execute the corresponding `DELETE` statement in the database.
            - After successful deletion, the entity will be **detached** from the `DbContext` (state becomes `Detached`).
            
            ```csharp
            int affectedRows = await context.SaveChangesAsync();
            if (affectedRows > 0)
            {
                Console.WriteLine($"Product {productIdToDelete} deleted successfully.");
                // Console.WriteLine($"State after save: {context.Entry(productToDelete).State}"); // Output: Detached
            }
            ```
            
- ExecuteUpdate and ExecuteDelete (>= EF Core 7)
    
    These are new methods introduced in EF Core 7, providing a **more efficient way** to perform **bulk update or delete** operations **without loading data into memory** and **without using the Change Tracker**.
    
    - **Motivation:** When you want to update/delete many records based on a condition (e.g., increase price by 5% for all products in a category, or delete all orders older than 1 year), loading each entity, modifying/deleting, and saving can be resource-intensive (memory, CPU, time).
    - **How it works:** These methods let you build a LINQ query to select the records (`Where()`), then specify the update actions (`ExecuteUpdateAsync`) or just delete (`ExecuteDeleteAsync`). EF Core will directly translate this into a single `UPDATE` or `DELETE` statement and execute it on the database.
    - **`ExecuteDeleteAsync()`**: Deletes records matching the `Where()` condition.
        
        ```csharp
        // Delete all products with price below 10
        int deletedCount = await context.Products
                                        .Where(p => p.Price < 10)
                                        .ExecuteDeleteAsync(); // Executes DELETE immediately
        Console.WriteLine($"{deletedCount} products were deleted.");
        // **No need to call SaveChangesAsync()**
        ```
        
    - **`ExecuteUpdateAsync()`**: Updates specified columns for records matching the `Where()` condition.
        
        ```csharp
        // Increase price by 5% and mark as unavailable for products in CategoryId = 2
        int updatedCount = await context.Products
                                        .Where(p => p.CategoryId == 2)
                                        .ExecuteUpdateAsync(setters => setters
                                            .SetProperty(p => p.Price, p => p.Price * 1.05m) // Update Price based on current value
                                            .SetProperty(p => p.IsAvailable, false) // Set IsAvailable to a fixed value
                                        ); // Executes UPDATE immediately
        Console.WriteLine($"{updatedCount} products were updated.");
        // **No need to call SaveChangesAsync()**
        ```
        
    - **Advantages:**
        - **High performance:** Executes a single SQL statement for many records.
        - **Memory efficient:** No need to load entities into client memory.
        - **Fast:** Skips the overhead of the Change Tracker.
    - **Disadvantages and Notes:**
        - **Bypasses Change Tracker:** Does not track changes or automatically update the state of any entities (if present) in the `DbContext`.
        - **Executes immediately:** The SQL statement is sent as soon as the method is called, not waiting for `SaveChangesAsync()`.
        - **Does NOT trigger SaveChanges() events/interceptors:** If you have custom logic in `SaveChanges()`, it will be skipped.
        - **Concurrency Control:** Concurrency control based on the Change Tracker is not applied.
        - **Cascading Actions:** Cascading delete/update actions may behave differently (depending on database configuration) compared to using `SaveChanges()`.
    - **When to use?** When you need to perform simple UPDATE/DELETE operations on **many records** based on a filter and **performance is a top priority**. Not a complete replacement for using the Change Tracker, especially when you need to handle complex logic or update relationships.
- Section Review
    - `DbContext` and `ChangeTracker` are central to change management in EF Core, tracking entity states (`Added`, `Modified`, `Deleted`, etc.).
    - `SaveChangesAsync()` is the final command to convert tracked changes into SQL (`INSERT`, `UPDATE`, `DELETE`) and execute them in a transaction.
    - **Insert:** Create new -> `Add()`/`AddRange()` -> `SaveChangesAsync()`.
    - **Update:** Query -> Modify properties -> `SaveChangesAsync()`.
    - **Delete:** Query -> `Remove()`/`RemoveRange()` -> `SaveChangesAsync()`.
    - **`ExecuteUpdateAsync()`** and **`ExecuteDeleteAsync()`** (EF Core 7+) provide efficient ways to bulk update/delete directly in the database, bypassing the Change Tracker, useful for performance-critical scenarios.
- Section Source Code
